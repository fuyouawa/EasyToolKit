# 代码风格指南

## 目录

- [var 使用规范](#var-使用规范)

---

## var 使用规范

**基本原则**：类型明显时使用 `var`，类型不明时显式声明

---

### ✅ 推荐使用 var 的场景

**1. 构造函数创建对象**
```csharp
var player = new Player();
var list = new List<int>();
var dictionary = new Dictionary<string, int>();
```

**2. 集合访问和简单赋值**
```csharp
var player = _players[id];
var count = players.Count;
var name = player.Name;
var isActive = true;
var count = 0;
```

**3. foreach 循环变量**
```csharp
foreach (var player in players)
{
    Debug.Log(player.Name);
}

// 类型明确的字典遍历
foreach (var (id, player) in playerById)
{
    Debug.Log($"{id}: {player.Name}");
}
```

**4. LINQ 查询结果（链式调用上下文清晰）**
```csharp
var activePlayers = players.Where(p => p.IsActive).ToList();
var enemyNames = enemies.Select(e => e.Name).ToArray();
var firstItem = items.FirstOrDefault();
```

**5. 泛型方法调用（类型参数可推断）**
```csharp
var result = GetOrCreate<Player>(playerId);
var pool = ObjectPool.Create<GameObject>();
```

---

### ❌ 应显式声明类型的场景

**1. 函数返回值（类型不明确）**
```csharp
// ❌ 类型不明确
var damage = CalculateDamage(attacker, target);
var data = LoadConfig(path);

// ✅ 显式声明
float damage = CalculateDamage(attacker, target);
ConfigData data = LoadConfig(path);
```

**2. 复杂泛型类型**
```csharp
// ❌ 类型冗长且不明确
var playerGroups = new Dictionary<int, List<Player>>();
var handlers = new Dictionary<EventKey, List<Delegate>>();

// ✅ 显式声明（或使用类型别名）
Dictionary<int, List<Player>> playerGroups = new();
Dictionary<EventKey, List<Delegate>> handlers = new();
```

**3. 数值类型（需要明确精度）**
```csharp
// ❌ 精度不明确
var distance = Vector3.Distance(a, b);
var deltaTime = Time.deltaTime;

// ✅ 显式声明
float distance = Vector3.Distance(a, b);
float deltaTime = Time.deltaTime;
```

**4. 接口类型（需要强调抽象）**
```csharp
// ❌ 掩盖了接口抽象
var list = new List<Player>();
var collection = GetPlayers();

// ✅ 显式声明接口类型
IList<Player> list = new List<Player>();
IEnumerable<Player> collection = GetPlayers();
```

**5. bool 或可空类型（需要强调语义）**
```csharp
// ❌ 类型不明确
var isValid = Validate(input);
var value = GetValue();

// ✅ 显式声明
bool isValid = Validate(input);
int? value = GetValue();
```

---

### 特殊场景

**1. 模式匹配**
```csharp
if (obj is Player player)
{
    // player 已被正确推断为 Player 类型
    Debug.Log(player.Name);
}

// switch 表达式
var result = input switch
{
    > 0 => "positive",
    < 0 => "negative",
    _ => "zero"
};
```

**2. 元组解构**
```csharp
var (success, data) = TryParse(input);
var (x, y, z) = GetPosition();
```

**3. var 滥用反模式**
```csharp
// ❌ 避免：类型完全不明
var value = SomeMethod();      // 什么类型？
var items = GetData()[0];      // GetData 返回什么？

// ❌ 避免：丢失类型信息
var list = new List<Player>();           // 实际是 List，但可能是 IList
var dict = new Dictionary<int, int>();   // 实际是 Dictionary，但可能是 IDictionary
```

---
