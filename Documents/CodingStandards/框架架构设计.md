# EasyToolkit 框架架构设计

## 1. 设计理念

EasyToolkit 采用模块化架构，将框架划分为多个独立的工具模块。每个模块遵循**职责单一、接口驱动、扩展优先**的设计原则。

核心设计理念：

- **依赖倒置**：用户代码依赖抽象接口，而非具体实现
- **分层清晰**：Abstractions（接口层）与 Implementations（实现层）物理分离
- **扩展友好**：通过接口、抽象类和策略模式提供扩展点
- **统一规范**：所有模块遵循一致的命名和组织规范

## 2. 架构分层

### 2.1 依赖方向

```
用户代码
   ↓ 依赖
Abstractions（接口层）
   ↑ 实现
Implementations（实现层）
```

用户代码始终依赖接口，具体实现通过工厂或依赖注入提供。这种设计确保：

- 实现可以替换而不影响用户代码
- 接口定义稳定的契约
- 实现细节封装在内部

### 2.2 分层职责

**Abstractions（接口层）**
- 定义模块的核心接口和抽象
- 对外公开的 API 契约
- 委托类型、泛型约束

**Implementations（实现层）**
- 具体功能的实现代码
- 使用独立的命名空间（`.Implementations`）
- 对外不可见，通过接口访问

**Models（模型层）**
- 公开的数据结构
- 枚举、结构体、配置类
- 与接口使用相同命名空间

## 2.3 标准模块结构

标准模块应遵循以下文件结构：

```
[Module]/
    ├── [Entry].cs            # 入口类
    │
    ├── Abstractions/            # 抽象层 - 接口定义
    │   ├── IXxx.cs
    │   ├── IXxxBuilder.cs
    │   ├── IXxxManager.cs
    │
    ├── Implementations/         # 实现层 - 具体实现类
    │   ├── Core/               # 核心基类
    │   │   └── XxxBase.cs
    │   │
    │   ├── XxxManager.cs       # 管理器实现
    │   ├── XxxBuilder.cs       # 构建器实现
    │   │
    │   └── [FeatureImpl]/      # 特定功能实现(可选)
    │       └── ...
    │
    ├── Configurations/          # 配置层 - 配置接口(可选)
    │   └── IXxxConfiguration.cs
    │
    ├── Models/                  # 数据模型
    │   └── XxxModel.cs
    │
    ├── Extensions/              # 扩展方法(可选)
    │   ├── XxxBuilderExtensions.cs
    │   └── XxxExtensions.cs
    │
    └── Utilities/               # 工具类(可选)
        └── XxxUtility.cs
```

### 文件夹职责说明

| 文件夹 | 职责 | 访问性 |
|--------|------|--------|
| `Abstractions/` | 接口层 - 所有公共接口定义,供外部引用和扩展 | 公开 |
| `Implementations/` | 实现层 - 具体实现类,包含核心逻辑 | 内部 |
| `Configurations/` | 配置层 - 配置相关的接口定义 | 公开 |
| `Models/` | 模型层 - 数据传输对象、值对象 | 公开 |
| `Extensions/` | 扩展层 - 扩展方法,提供便捷 API | 公开 |
| `Utilities/` | 工具层 - 辅助工具类、帮助方法 | 按需 |

### 组织原则

1. **物理分离**：接口和实现分放在不同目录
2. **命名空间隔离**：实现类使用 `.Implementations` 子命名空间
3. **单一入口**：每个系统通常通过 `XxxFactory`、`XxxManager` 作为入口
4. **依赖方向**：上层依赖下层，不允许反向依赖

## 3. 核心设计模式

### 3.1 依赖倒置原则（DIP）

高层模块不应依赖低层模块，两者都应依赖抽象。

```csharp
// 用户代码依赖接口
IEventBus eventBus = ReflectionFactory.CreateEventBus();
eventBus.Dispatch(new MyEvent());
```

### 3.2 工厂模式

工厂类作为模块的主入口，提供统一的对象创建方式。

```csharp
public static class ReflectionFactory
{
    public static IAccessorBuilder CreateAccessor(string memberPath);
}
```

### 3.3 建造者模式

分步骤构建复杂对象，提供流畅的链式 API。

```csharp
var pool = PoolManagerFactory.CreateBuilder()
    .WithInitialCapacity(10)
    .WithMaxSize(100)
    .Build(() => new MyObject());
```

### 3.4 策略模式

将算法封装为独立接口，支持运行时替换和扩展。

```csharp
public interface ITypeMatchRule
{
    TypeMatchResult Match(Type source, Type target);
}

// 用户可实现自定义策略
public class CustomMatchRule : ITypeMatchRule { }
```

## 4. 扩展性设计

### 4.1 设计目的

扩展方法服务于两个核心目的：

**1. 提供链式调用API**
- 为Builder、Configuration等接口提供流畅的配置方法。扩展方法设置配置属性后返回接收者本身，支持连续调用。

**2. 提供功能封装**
- 为底层API提供类型安全或简化的封装层。扩展方法包装复杂的底层调用，暴露简洁的强类型接口。

### 4.2 实现模式

**链式配置扩展**
- 使用泛型约束确保返回类型兼容性
- `WithXxx` 命名规范表达配置意图
- 适用于Builder、Configuration等配置对象

```csharp
// Builder扩展 - 返回泛型类型支持继承链
public static TBuilder WithInitialCapacity<TBuilder>(
    this TBuilder builder, int capacity)
    where TBuilder : IPoolBuilder
{
    builder.InitialCapacity = capacity;
    return builder;
}
```

**功能封装扩展**
- 包装非泛型API为强类型API
- 自动处理类型转换和参数适配
- 提升类型安全性，简化调用代码

```csharp
// 泛型API扩展 - 包装底层类型转换
public static StaticGetter<TValue> BuildStaticGetter<TValue>(
    this IAccessorBuilder builder, Type targetType)
{
    var getter = builder.BuildStaticGetter(targetType);
    return () => (TValue)getter();
}
```

### 4.3 组织规范

- 文件位置：`Extensions/[TargetName]Extensions.cs`
- 静态类命名：与文件名一致
- 专注原则：每个扩展类对应一个目标类型

## 5. 设计原则

### 5.1 SOLID 原则

- **单一职责（SRP）**：每个类只有一个改变的理由
- **开闭原则（OCP）**：对扩展开放，对修改关闭
- **里氏替换（LSP）**：子类可替换父类使用
- **接口隔离（ISP）**：接口设计小而专注
- **依赖倒置（DIP）**：依赖抽象而非具体实现

### 5.2 其他原则

- **DRY**：避免重复代码
- **KISS**：保持简单
- **YAGNI**：不过度设计
