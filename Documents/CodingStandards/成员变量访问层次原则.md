# 成员变量访问层次原则

## 基本原则

在 Unity 类的内部代码中，推荐使用**原始字段**直接访问，除非属性中包含逻辑副作用（验证、事件、延迟加载等）。

如果属性包含逻辑或未来可能扩展副作用，则应统一使用属性访问。

---

## 纯数据类 / 无逻辑属性

**适用场景**：属性仅作为数据访问的简单封装，不包含额外逻辑

**访问原则**：类内部推荐直接访问原始字段

```csharp
public class PlayerData : MonoBehaviour
{
    [SerializeField] private int _playerId;
    [SerializeField] private string _playerName;

    public int PlayerId => _playerId;      // 纯数据属性
    public string PlayerName => _playerName; // 纯数据属性

    private void Awake()
    {
        // ✅ 推荐直接访问原始字段
        _playerId = 1001;

        // ❌ 避免使用属性访问纯数据
        // PlayerId = 1001; // 不推荐
    }
}
```

---

## 属性包含逻辑或事件

**适用场景**：属性包含验证、事件触发、延迟加载等逻辑

**访问原则**：类内部必须使用属性访问以确保逻辑正确执行

```csharp
public class HealthSystem : MonoBehaviour
{
    [SerializeField] private float _maxHealth = 100f;
    private float _currentHealth;

    public float CurrentHealth
    {
        get => _currentHealth;
        private set
        {
            // 属性包含逻辑：数值限制和事件触发
            _currentHealth = Mathf.Clamp(value, 0, _maxHealth);
            OnHealthChanged?.Invoke(_currentHealth);
        }
    }

    public event System.Action<float> OnHealthChanged;

    private void Awake()
    {
        // ✅ 必须使用属性访问，因为属性包含逻辑
        CurrentHealth = _maxHealth;

        // ❌ 不能直接访问原始字段，会跳过验证逻辑
        // _currentHealth = _maxHealth; // 错误！
    }

    public void TakeDamage(float damage)
    {
        // ✅ 必须使用属性访问
        CurrentHealth -= damage;
    }
}
```

---

## 使用总结

| 场景 | 访问方式 | 原因 |
|------|---------|------|
| **纯数据属性** | 直接访问原始字段 | 避免不必要的属性调用开销 |
| **逻辑属性** | 使用属性访问 | 确保验证、事件等逻辑正确执行 |
| **读取操作** | 使用字段或属性均可 | 建议保持一致性 |

---

## 判断依据

### 应该直接访问字段的情况：
- 属性没有 getter/setter 逻辑
- 属性仅用于外部访问控制
- 属性未来不太可能添加逻辑

### 必须使用属性访问的情况：
- 属性包含数据验证逻辑
- 属性触发事件
- 属性包含延迟加载
- 属性有副作用（如修改其他字段）

---
