# 项目代码规范

## 注意事项
示例代码中的注释仅为辅助理解的作用，并不是要求加入代码规范的部分。

比如下列这一段示例
```csharp
public class Example
{
    // ====== 常量 ======
    public const int MaxCount = 100;
    private const string DefaultName = "Unknown";

    ...
```
这里的“// ====== 常量 ======”注释只是提示这些变量是属于常量的，并不是要求代码中真的要在常量变量的部分前加上这一段注释。

（提这一嘴主要是给AI看的，点名deepseek理解能力堪忧，把提示用的注释也生成到代码里面）

## 类成员的排列

**排列顺序**（从上到下）：

1. 常量（`const`）
2. 静态只读字段（`static readonly`）
3. 静态字段（`static`）
4. 实例字段（`private`/`protected`）
5. 构造函数
6. 属性（`Properties`）
7. 方法（`Methods`）

**访问修饰符顺序**：`public` → `protected` → `private`

---

### 普通类示例

```csharp
public class Example
{
    // ====== 常量 ======
    public const int MaxCount = 100;
    private const string DefaultName = "Unknown";

    // ====== 静态只读字段 ======
    public static readonly Example Empty = new Example();
    private static readonly Random _rng = new Random();

    // ====== 静态字段 ======
    private static int s_globalCounter;

    // ====== 实例字段 ======
    private int _id;
    private string _name;

    // ====== 构造函数 ======
    public Example(int id, string name)
    {
        _id = id;
        _name = name;
    }

    // ====== 属性 ======
    public int Id => _id;

    public string Name
    {
        get => _name;
        set => _name = value ?? DefaultName;
    }

    // ====== 公共方法 ======
    public static Example CreateRandom()
    {
        return new Example(_rng.Next(MaxCount), "Random");
    }

    // ====== 私有方法 ======
    private void Reset()
    {
        _id = 0;
        _name = DefaultName;
    }
}
```

---

### Unity 类示例

**Unity 特殊排列顺序**（从上到下）：

1. 常量 / 静态字段
2. 序列化字段（`[SerializeField]`）
3. 私有字段
4. 公共属性
5. Unity 生命周期方法（按调用顺序）
6. 公共方法
7. 私有方法
8. 协程

**序列化字段规范**：
- 序列化字段最好使用 `[SerializeField]` 加上 `private` 访问修饰符
- 如果需要外部访问，通过属性提供访问接口
- 属性可以包含验证逻辑，确保数据安全

```csharp
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    // ====== 常量 / 静态字段 ======
    private const float MaxHealth = 100f;
    private static readonly Vector3 DefaultSpawn = Vector3.zero;

    // ====== 序列化字段 ======
    [SerializeField] private float _moveSpeed = 5f;
    [SerializeField] private Rigidbody2D _rigidbody;
    [SerializeField] private float _maxHealth = 100f;

    // ====== 私有字段 ======
    private float _health;
    private Vector2 _input;

    // ====== 公共属性 ======
    public bool IsAlive => _health > 0;

    public float MoveSpeed
    {
        get => _moveSpeed;
        set => _moveSpeed = Mathf.Max(0, value);
    }

    public float MaxHealth => _maxHealth;

    public float Health
    {
        get => _health;
        private set => _health = Mathf.Clamp(value, 0, _maxHealth);
    }

    // ====== Unity 生命周期方法 ======
    private void Awake()
    {
        _health = MaxHealth;
    }

    private void OnEnable()
    {
        // 注册事件
    }

    private void Start()
    {
        Spawn(DefaultSpawn);
    }

    private void Update()
    {
        HandleInput();
    }

    private void FixedUpdate()
    {
        Move();
    }

    private void OnDisable()
    {
        // 取消注册事件
    }

    private void OnDestroy()
    {
        // 清理资源
    }

    // ====== 公共方法 ======
    public void TakeDamage(float amount)
    {
        _health = Mathf.Max(0, _health - amount);
    }

    // ====== 私有方法 ======
    private void HandleInput()
    {
        _input = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
    }

    private void Move()
    {
        _rigidbody.velocity = _input * _moveSpeed;
    }

    private void Spawn(Vector3 position)
    {
        transform.position = position;
    }

    // ====== 协程 ======
    private System.Collections.IEnumerator RespawnCoroutine()
    {
        yield return new WaitForSeconds(3f);
        Spawn(DefaultSpawn);
        _health = MaxHealth;
    }
}
```

---

## 成员变量访问层次原则

### 基本原则

1. 在 Unity 类的内部代码中，推荐使用**原始字段**直接访问，除非属性中包含逻辑副作用（验证、事件、延迟加载等）。

2. 如果属性包含逻辑或未来可能扩展副作用，则应统一使用属性访问。

### 示例场景

#### 纯数据类 / 无逻辑属性

```csharp
public class PlayerData : MonoBehaviour
{
    [SerializeField] private int _playerId;
    [SerializeField] private string _playerName;

    public int PlayerId => _playerId;      // 纯数据属性
    public string PlayerName => _playerName; // 纯数据属性

    private void Awake()
    {
        // ✅ 推荐直接访问原始字段
        _playerId = 1001;

        // ❌ 避免使用属性访问纯数据
        // PlayerId = 1001; // 不推荐
    }
}
```

#### 属性包含逻辑或事件

```csharp
public class HealthSystem : MonoBehaviour
{
    [SerializeField] private float _maxHealth = 100f;
    private float _currentHealth;

    public float CurrentHealth
    {
        get => _currentHealth;
        private set
        {
            // 属性包含逻辑：数值限制和事件触发
            _currentHealth = Mathf.Clamp(value, 0, _maxHealth);
            OnHealthChanged?.Invoke(_currentHealth);
        }
    }

    public event System.Action<float> OnHealthChanged;

    private void Awake()
    {
        // ✅ 必须使用属性访问，因为属性包含逻辑
        CurrentHealth = _maxHealth;

        // ❌ 不能直接访问原始字段，会跳过验证逻辑
        // _currentHealth = _maxHealth; // 错误！
    }

    public void TakeDamage(float damage)
    {
        // ✅ 必须使用属性访问
        CurrentHealth -= damage;
    }
}
```

### 总结

1. **纯数据属性**：类内部推荐直接访问原始字段
2. **逻辑属性**：类内部必须使用属性访问以确保逻辑正确执行
3. **读取操作**：使用属性或字段均可，建议保持一致

---

## 变量命名规范

### 通用法则

1. 除了常用的那些名词允许缩写，其他的都尽量不要使用缩写

### 普通集合

**写法**：使用**复数**形式

**示例**：

```csharp
List<Player> players;
Player[] onlinePlayers;
Dictionary<int, Enemy> enemies;
```

---

### Dictionary

**写法**：使用 **XxxByYyy**（**ValueByKey**）风格

**规则**：

- `Xxx` 使用单数，除非是集合类型
- **语义**：`Xxx` 是根据 `Yyy` 得到的

**示例**：

```csharp
// 单个值
Dictionary<int, Player> playerById;
Dictionary<string, Item> itemByName;

// 集合值（Xxx 用复数）
Dictionary<string, AssetInfo[]> assetInfosByPackageName;
Dictionary<int, List<Quest>> questsByPlayerId;
```

---

### TaskCompletionSource

**写法**：**动作语义** + **Tcs** 后缀

**示例**：

```csharp
TaskCompletionSource<int> clickCompletedTcs;
TaskCompletionSource<bool> loginTcs;
Dictionary<string, UniTaskCompletionSource<UnityEngine.Object>> assetLoadTcsByName;
```

---

### Event

**写法**：`Xxxing` / `Xxxed`（不加 `On` 前缀）

**基本原则**：

1. **事件名**应该描述"发生了什么"，而不是"去做什么"
   - ✅ `Closed`、`Clicked`、`Completed`
   - ❌ `Close`、`Click`、`Complete`

2. 不要给事件加 `On` 前缀，`OnXxx` 一般保留给触发事件的方法

3. **时态区分**：
   - `Xxxing` → 表示"正在进行，可以被取消或干预"
     - 例：`Closing`、`Loading`、`Connecting`
   - `Xxxed` → 表示"已经完成，通知外部结果"
     - 例：`Closed`、`Loaded`、`Connected`

**示例**：

```csharp
public class Window
{
    // 事件定义
    public event Action Closing;                    // 窗口正在关闭
    public event Action Closed;                     // 窗口已经关闭
    public event Action<Exception> CloseFailed;     // 窗口关闭失败

    // 触发方法（使用 On 前缀）
    protected virtual void OnClosing() => Closing?.Invoke();
    protected virtual void OnClosed() => Closed?.Invoke();
    protected virtual void OnCloseFailed(Exception ex) => CloseFailed?.Invoke(ex);
}
```

---

### Delegate

**写法**：以 **XxxHandler** 作为后缀

**基本原则**：

1. Delegate 通常表示一类方法签名，应以 **Handler** 结尾，以强调"处理某事的方法"
2. Delegate 名称应体现**它要处理的事件或动作**，避免模糊
3. 若返回值为 `bool`，可命名为 **XxxPredicate** 或 **XxxEvaluator**，表示条件判断或计算
4. Delegate 命名与事件相配合时，应与事件名的语义保持一致

**示例**：

```csharp
// 普通事件回调
public delegate void WindowClosedHandler(Window window);
public event WindowClosedHandler Closed;

// 条件判断
public delegate bool PlayerPredicate(Player player);
public Player FindPlayer(PlayerPredicate predicate);

// 特殊用途（如计算/转换）
public delegate int DamageEvaluator(Player attacker, Player target);
public int CalculateDamage(DamageEvaluator evaluator);
```

---

### 排序/比较器

**基本原则**：

1. **一次性 Lambda 表达式**：使用 **a、b** 作为参数名
   - 适用于内联的、一次性的排序逻辑
   - 简洁明了，符合 C# 社区约定

2. **公共方法 / 工具类**：使用 **left、right** 作为参数名
   - 适用于可重用的比较方法
   - 语义更清晰，便于理解

**示例**：

```csharp
// ✅ 一次性 Lambda 表达式 - 使用 a、b
list.Sort((a, b) => a.Id.CompareTo(b.Id));
items.OrderBy((a, b) => a.Priority.CompareTo(b.Priority));

// ✅ 公共比较方法 - 使用 left、right
public int Compare(Item left, Item right)
{
    return left.Id.CompareTo(right.Id);
}
```

---

## 函数命名规范

### 获取类函数前缀规则

#### Get 前缀
- **核心语义**："获取"，预期一定能找到目标，找不到时抛出异常
- **使用场景**：
  - 时间复杂度通常为 O(1)
  - 预期目标一定存在
  - 找不到或出错时抛出异常
- **示例**：
  ```csharp
  // 示例：从字典中获取玩家，找不到时抛异常
  public Player GetPlayer(int playerId)
  {
      if (!_players.TryGetValue(playerId, out var player))
          throw new PlayerNotFoundException(playerId);
      return player;
  }
  ```

#### Find 前缀
- **核心语义**："查找"，可能需要搜索/遍历，找不到时返回 null
- **使用场景**：
  - 通常需要搜索/遍历/匹配条件
  - 时间复杂度可能大于 O(1)
  - 找不到时返回 null
- **示例**：
  ```csharp
  // 示例：根据名称查找玩家，可能找不到
  public Player FindPlayerByName(string name)
  {
      return _players.Values.FirstOrDefault(p => p.Name == name);
  }
  ```

#### TryGet 前缀
- **核心语义**："安全获取"，返回 bool 表示成功/失败，通过 out 参数传出结果
- **使用场景**：
  - Get 的异常安全版本
  - 返回 bool 表示成功/失败
  - 结果通过 out 参数返回
- **示例**：
  ```csharp
  // 示例：安全获取玩家，不抛异常
  public bool TryGetPlayer(int playerId, out Player player)
  {
      return _players.TryGetValue(playerId, out player);
  }
  ```

### 计算类函数前缀规则

#### Compute 前缀
- **核心语义**：通过算法或逻辑过程推导结果
- **使用场景**：
  - 更抽象、更智能、可包含多步骤推理
  - 复杂逻辑、配置推导、路径规划、状态评估
  - 性能敏感的计算操作
- **示例**：
  ```csharp
  // 示例：需要读取配置、筛选、推导，非单纯算式
  public float ComputeLearnableSkills(Player target);
  ```

#### Calculate 前缀
- **核心语义**：通过数学公式或明确算式得出结果
- **使用场景**：
  
  - 更精确、更数学化、一步到位的数值计算
  - 数值、比例、伤害、数值成长
- **示例**：
  ```csharp
  // 示例：计算经验值需求，有固定数学公式或比例
  public int CalculateExpRequired(int currentLevel);
  ```

#### Can 前缀
- **核心语义**："能否"，用于判断某个操作是否可行
- **使用场景**：
  - 具备执行某行为的条件
  - 判断能做不做
- **示例**：
  ```csharp
  // 示例：判断玩家能否使用技能
  public bool CanUseSkill(Player player, Skill skill);
  ```

#### Is 前缀
- **核心语义**："是否"，用于判断状态或属性
- **使用场景**：
  - “当前具备某种状态
  - 判断是与否
- **示例**：
  ```csharp
  // 示例：判断玩家是否在线
  public bool IsPlayerOnline(int playerId);
  ```

### 后缀规则

#### ByXxx 后缀
- **核心语义**："根据Xxx来..."
- **使用场景**：
  - 通过唯一标识符查找：`ById`, `ByName`, `ByKey`
  - 通过条件筛选：`ByLevel`, `ByStatus`, `ByType`
  - 通过参数匹配：`ByAccount`, `ByEmail`, `ByPhone`
- **示例**：
  
  ```csharp
  public Player GetPlayerById(int id);
  public Item FindItemByName(string name);
  public bool TryGetConfigByKey(string key, out Config config);
  ```

#### AtXxx 后缀
- **核心语义**："在Xxx位置/时间..."
- **使用场景**：
  - 空间位置：`AtPosition`, `AtCoordinate`, `AtLocation`
  - 数组索引：`AtIndex`, `AtSlot`, `AtPosition`
  - 时间点：`AtTime`, `AtDate`, `AtTimestamp`
- **示例**：
  
  ```csharp
  public Item GetItemAt(Vector3 position);
  public Enemy FindEnemyAt(Vector2 coord);
  public bool TryGetTileAt(int x, int y, out Tile tile);
  ```

#### OfXxx 后缀
- **核心语义**："属于Xxx的..." 或 "具有Xxx属性的..."
- **使用场景**：
  - 归属关系：`OfPlayer`, `OfTeam`, `OfGuild`
  - 属性关系：`OfType`, `OfCategory`, `OfRarity`
  - 组成部分：`OfSystem`, `OfModule`, `OfComponent`
- **示例**：
  ```csharp
  public Skill GetSkillOfPlayer(int playerId);
  public List<Item> FindItemsOfType(ItemType type);
  public bool TryGetConfigOfModule(string module, out Config config);
  ```

#### 补充

**必须使用后缀的情况**：

1. 同一个实体支持多种 key 查找时，必须显式区分
   ```csharp
   // ✅ 正确：明确区分不同的查找方式
   public Player GetPlayerById(int id);
   public Player GetPlayerByName(string name);
   public Player GetPlayerByAccount(string account);
   ```

2. 参数类型相同，但语义不同，需要写清楚
   ```csharp
   // ✅ 正确：虽然都是int参数，但语义不同
   public Item GetItemById(int id);        // 根据物品ID获取
   public Item GetItemByIndex(int index);  // 根据索引位置获取
   ```

**可以不加后缀的情况**：
- 上下文已明确语境，类名/命名空间已经说明了"查找基准"
  ```csharp
  // ✅ 正确：在PlayerManager类中，GetPlayer默认按ID查找
  public class PlayerManager
  {
      public Player GetPlayer(int playerId);  // 不需要GetPlayerById
  }
  ```

- 明确只有一种查找方式，语义唯一
  ```csharp
  // ✅ 正确：地图类中只有按坐标查找一种方式
  public class Map
  {
      public Tile GetTile(Vector3 position);  // 不需要GetTileAt
  }
  ```

**不确定原则**：如果不确定后续是否会由于API增加导致不满足不加后缀的情况，那么使用加后缀的原则

---

## 日志和错误信息规范

### 日志级别定义

**日志级别使用原则**：

1. **Debug** - 调试信息，用于开发阶段排查问题
   - 包含详细的方法调用、参数值、中间状态
   - 生产环境通常关闭

2. **Info** - 常规信息，记录系统正常运行状态
   - 重要的业务操作、状态变更
   - 用户登录、关键数据更新等

3. **Warning** - 警告信息，表示潜在问题但系统仍可运行
   - 非关键错误、降级处理、配置问题
   - 资源不足、性能警告等

4. **Error** - 错误信息，表示功能失败但系统可继续运行
   - 业务逻辑错误、外部服务调用失败
   - 数据验证失败、权限不足等

5. **Fatal** - 致命错误，系统无法继续运行
   - 关键组件初始化失败、内存耗尽
   - 数据库连接失败等

### 日志消息格式规范

**基本格式**：`[Context] Action: Description (Details)`

**组件说明**：
- **Context**：日志发生的上下文（类名、模块名）
- **Action**：执行的操作或事件
- **Description**：操作结果或状态描述
- **Details**：相关参数、错误信息等详细信息

**示例**：
```csharp
// Debug 级别
Debug.Log($"[Player] PlayerLogin: Player {playerId} logged in (Name: {playerName})");

// Info 级别
Logger.Info($"[Player] PlayerJoined: Player {playerId} joined the game (Position: {position})");

// Warning 级别
Logger.Warning($"[Resource] AssetLoadFailed: Failed to load asset {assetPath} (Reason: {error.Message})");

// Error 级别
Logger.Error($"[Network] ConnectionLost: Lost connection to server {serverAddress} (Error: {exception.Message})");
```

### 错误信息语法规范

**错误消息结构**：`What happened? Why it happened? How to fix?`

**组件说明**：
- **What**：发生了什么错误
- **Why**：错误的原因（如果知道）
- **How**：如何解决或下一步操作

**示例**：
```csharp
// 验证错误
throw new ArgumentException("Player name cannot be empty. Name validation failed. Please provide a valid player name.");

// 业务逻辑错误
throw new InvalidOperationException("Cannot attack while dead. Player health is 0. Revive player before attacking.");

// 资源错误
throw new FileNotFoundException("Asset file not found. File path is invalid or file does not exist. Check the asset path and ensure the file exists.");
```

### 异常处理规范

**异常捕获原则**：

1. **只捕获你能处理的异常**
2. **使用具体的异常类型**，避免捕获通用 Exception
3. **记录异常上下文信息**
4. **重新抛出时保留原始异常**

**示例**：
```csharp
public void LoadPlayerData(int playerId)
{
    try
    {
        var data = _dataService.GetPlayerData(playerId);
        // 处理数据
    }
    catch (DataServiceException ex)
    {
        // 记录详细的错误信息
        Logger.Error($"[PlayerService] LoadPlayerDataFailed: Failed to load player data for {playerId} " +
                     $"(Error: {ex.Message}, Inner: {ex.InnerException?.Message})");

        // 抛出业务异常，保留原始异常
        throw new PlayerDataLoadException($"Failed to load player data for {playerId}", ex);
    }
    catch (TimeoutException ex)
    {
        // 处理超时异常
        Logger.Warning($"[PlayerService] LoadPlayerDataTimeout: Timeout loading player data for {playerId}");
        throw;
    }
}
```

### 自定义异常规范

**命名规则**：`XxxException`

**构造函数要求**：
- 提供有意义的错误消息
- 支持传递内部异常
- 可选的错误代码或上下文数据

**示例**：

```csharp
public class PlayerNotFoundException : Exception
{
    public int PlayerId { get; }

    public PlayerNotFoundException(int playerId)
        : base($"Player with ID {playerId} was not found. The player may not exist or has been deleted.")
    {
        PlayerId = playerId;
    }

    public PlayerNotFoundException(int playerId, Exception innerException)
        : base($"Player with ID {playerId} was not found. The player may not exist or has been deleted.", innerException)
    {
        PlayerId = playerId;
    }
}

public class InsufficientResourceException : Exception
{
    public string ResourceType { get; }
    public int Required { get; }
    public int Available { get; }

    public InsufficientResourceException(string resourceType, int required, int available)
        : base($"Insufficient {resourceType}. Required: {required}, Available: {available}. " +
               $"Please acquire more {resourceType} or reduce the requirement.")
    {
        ResourceType = resourceType;
        Required = required;
        Available = available;
    }
}
```